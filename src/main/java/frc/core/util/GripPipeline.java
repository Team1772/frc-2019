import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.HashMap;

import org.opencv.core.*;
import org.opencv.core.Core.*;
import org.opencv.features2d.FeatureDetector;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.*;
import org.opencv.objdetect.*;

/**
* GripPipeline class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class GripPipeline {

	//Outputs
	private Mat desaturateOutput = new Mat();
	private Mat blurOutput = new Mat();
	private Size getMatInfoSize = new Size();
	private Boolean getMatInfoEmpty;
	private Number getMatInfoChannels;
	private Number getMatInfoCols;
	private Number getMatInfoRows;
	private Number getMatInfoHighValue;

	static {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
	}

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	public void process(Mat source0) {
		// Step Desaturate0:
		Mat desaturateInput = source0;
		desaturate(desaturateInput, desaturateOutput);

		// Step Blur0:
		Mat blurInput = desaturateOutput;
		BlurType blurType = BlurType.get("Box Blur");
		double blurRadius = 2.792792792792792;
		blur(blurInput, blurType, blurRadius, blurOutput);

		// Step Get_Mat_Info0:
		Mat getMatInfoInput = blurOutput;
		Ref<Boolean> getMatInfoEmptyRef = new Ref<Boolean>();
		Ref<Number> getMatInfoChannelsRef = new Ref<Number>();
		Ref<Number> getMatInfoColsRef = new Ref<Number>();
		Ref<Number> getMatInfoRowsRef = new Ref<Number>();
		Ref<Number> getMatInfoHighValueRef = new Ref<Number>();
		getMatInfo(getMatInfoInput, getMatInfoSize, getMatInfoEmptyRef, getMatInfoChannelsRef, getMatInfoColsRef, getMatInfoRowsRef, getMatInfoHighValueRef);
		getMatInfoEmpty = getMatInfoEmptyRef.get();
		getMatInfoChannels = getMatInfoChannelsRef.get();
		getMatInfoCols = getMatInfoColsRef.get();
		getMatInfoRows = getMatInfoRowsRef.get();
		getMatInfoHighValue = getMatInfoHighValueRef.get();

	}

	/**
	 * This method is a generated getter for the output of a Desaturate.
	 * @return Mat output from Desaturate.
	 */
	public Mat desaturateOutput() {
		return desaturateOutput;
	}

	/**
	 * This method is a generated getter for the output of a Blur.
	 * @return Mat output from Blur.
	 */
	public Mat blurOutput() {
		return blurOutput;
	}

	/**
	 * This method is a generated getter for the output of a Get_Mat_Info.
	 * @return Size output from Get_Mat_Info.
	 */
	public Size getMatInfoSize() {
		return getMatInfoSize;
	}

	/**
	 * This method is a generated getter for the output of a Get_Mat_Info.
	 * @return Boolean output from Get_Mat_Info.
	 */
	public Boolean getMatInfoEmpty() {
		return getMatInfoEmpty;
	}

	/**
	 * This method is a generated getter for the output of a Get_Mat_Info.
	 * @return Number output from Get_Mat_Info.
	 */
	public Number getMatInfoChannels() {
		return getMatInfoChannels;
	}

	/**
	 * This method is a generated getter for the output of a Get_Mat_Info.
	 * @return Number output from Get_Mat_Info.
	 */
	public Number getMatInfoCols() {
		return getMatInfoCols;
	}

	/**
	 * This method is a generated getter for the output of a Get_Mat_Info.
	 * @return Number output from Get_Mat_Info.
	 */
	public Number getMatInfoRows() {
		return getMatInfoRows;
	}

	/**
	 * This method is a generated getter for the output of a Get_Mat_Info.
	 * @return Number output from Get_Mat_Info.
	 */
	public Number getMatInfoHighValue() {
		return getMatInfoHighValue;
	}


	/**
	 * Converts a color image into shades of grey.
	 * @param input The image on which to perform the desaturate.
	 * @param output The image in which to store the output.
	 */
	private void desaturate(Mat input, Mat output) {
		switch (input.channels()) {
			case 1:
				// If the input is already one channel, it's already desaturated
				input.copyTo(output);
				break;
			case 3:
				Imgproc.cvtColor(input, output, Imgproc.COLOR_BGR2GRAY);
				break;
			case 4:
				Imgproc.cvtColor(input, output, Imgproc.COLOR_BGRA2GRAY);
				break;
			default:
				throw new IllegalArgumentException("Input to desaturate must have 1, 3, or 4 channels");
		}
	}

	/**
	 * An indication of which type of filter to use for a blur.
	 * Choices are BOX, GAUSSIAN, MEDIAN, and BILATERAL
	 */
	enum BlurType{
		BOX("Box Blur"), GAUSSIAN("Gaussian Blur"), MEDIAN("Median Filter"),
			BILATERAL("Bilateral Filter");

		private final String label;

		BlurType(String label) {
			this.label = label;
		}

		public static BlurType get(String type) {
			if (BILATERAL.label.equals(type)) {
				return BILATERAL;
			}
			else if (GAUSSIAN.label.equals(type)) {
			return GAUSSIAN;
			}
			else if (MEDIAN.label.equals(type)) {
				return MEDIAN;
			}
			else {
				return BOX;
			}
		}

		@Override
		public String toString() {
			return this.label;
		}
	}

	/**
	 * Softens an image using one of several filters.
	 * @param input The image on which to perform the blur.
	 * @param type The blurType to perform.
	 * @param doubleRadius The radius for the blur.
	 * @param output The image in which to store the output.
	 */
	private void blur(Mat input, BlurType type, double doubleRadius,
		Mat output) {
		int radius = (int)(doubleRadius + 0.5);
		int kernelSize;
		switch(type){
			case BOX:
				kernelSize = 2 * radius + 1;
				Imgproc.blur(input, output, new Size(kernelSize, kernelSize));
				break;
			case GAUSSIAN:
				kernelSize = 6 * radius + 1;
				Imgproc.GaussianBlur(input,output, new Size(kernelSize, kernelSize), radius);
				break;
			case MEDIAN:
				kernelSize = 2 * radius + 1;
				Imgproc.medianBlur(input, output, kernelSize);
				break;
			case BILATERAL:
				Imgproc.bilateralFilter(input, output, -1, radius, radius);
				break;
		}
	}

	/**
	 * Gets information about given mat.
	 * @param src Mat to get info about.
	 * @param size the size of the Mat.
	 * @param empty if the Mat is empty.
	 * @param channels number of channels in the Mat.
	 * @param cols number of rows in the Mat.
	 * @param rows number of columns in the Mat.
	 * @param highestValue highest value contained in the Mat.
	 */
		private void getMatInfo(Mat src, Size size, Ref<Boolean> empty,
	Ref<Number> channels, Ref<Number> cols, Ref<Number> rows, Ref<Number> highestValue) {
		empty.set(Boolean.valueOf(src.empty()));
		channels.set(Integer.valueOf(src.channels()));
		cols.set(Integer.valueOf(src.cols()));
		rows.set(Integer.valueOf(src.rows()));
		highestValue.set(Integer.valueOf((int)(Core.minMaxLoc(src.reshape(1)).maxVal)));
		Size matSize = src.size();
		size.height = matSize.height;
		size.width = matSize.width;
	}


	/**
	 * Enables C-style output parameters in Java to avoid creating custom data classes for each
	 * operation.
	 *
	 * <p>Syntax is {@code Ref<T> varName = new Ref<T>(initValue)}.
	 * Where varName is the name of the variable and initValue is of type T and contains initial value.
	 * </p>
	 * @param <T> The type of object being referenced
	 */
	private static class Ref<T> {
		private T value;

		/**
		 * Constructor for a Ref object.
		 * @param initValue Type T initial value for the object.
		 */
		public Ref(T initValue) {
			value = initValue;
		}

		/**
		 * Constructor for a Ref object without an initial value.
		 * Equivalent to calling Ref(null)
		 */
		public Ref() {
			this(null);
		}

		/**
		 * Sets the object to contain a new value.
		 *
		 * @param newValue the new value being referenced
		 */
		public void set(T newValue) {
			value = newValue;
		}

		/**
		 * Gets the current referenced value
		 *
		 * @return the current referenced value
		 */
		public T get() {
			return value;
		}
	}

}

